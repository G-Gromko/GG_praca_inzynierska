\chapter{Implementacja programu}
W rozdziale piątym zostały przedstawione najważniejsze fragmenty sposobu implementacji programu. 

\section{Realizacja detekcji pięciolinii}

Detekcja pięciolinii została opracowana na podstawie pracy M. Szwocha \textit{A Robust Detector for Distorted Music Staves} \cite{Szwoch2005}.

Jedną z najbardziej przydanych właściwości pięciolinii jest ich forma, mianowicie pięć prostych, równoodległych linii, co czyni je perfekcyjnymi kandydatami do detekcji zniekształceń wprowadzonych przez proces fotografowania, pozwalając na usunięcie niedoskonałości geometrycznych obrazu.

Proces detekcji pozycji pięciolinii na obrazie został zrealizowany przy pomocy analizy histogramów okienek próbnikowych. Okienkiem próbnikowym nazywany jest fragment obrazu rozciągający się na całą jego wysokość i pewną szerokość, przy pomocy którego dokonywana jest analiza obrazu, poprzez analizę jego mniejszych fragmentów. Po analizie okienka na danej części obrazu, jego pozycja jest przesuwana o daną odległość w osi poziomej, po czym następuje analiza następnego wycinka. Poszczególne okienka próbnikowe nie mają na siebie bezpośredniego wpływu podczas analizy.

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{images/probe window demo.jpg}
	\caption{Wizualizacja okienka próbnikowego na zdjęciu nut.}
	\label{fig:probe_window_demo}
\end{figure}

\pagebreak

\subsection{Realizacja detekcji pozycji wypaczonych pięciolinii na obrazie}

\begin{lstlisting}[caption={\pyth|find_staves_points()| - funkcja odnajdywania pozycji pięciolinii na obrazie}, label={find-staves-points}, language=Python]
def find_staves_points(img, img_name, stride = 2):
	img = enhance_image(img, img_name)
	
	img_y, img_x = img.shape[:2]
	
	staff_line_dist = find_staff_line_distance(img)
	if staff_line_dist == -1:
		return -1, 0
	
	staves_positions = find_staves_positions(staff_line_dist, stride, img)
	if len(staves_positions) == 0:
		return -1, -1
	else:
		staves_points_list = make_staves_points_list(staves_positions, staff_line_dist)
		if staves_points_list == -1  or len(staves_points_list) == 0:
			return -1, -1

	return staves_points_list, staff_line_dist
\end{lstlisting}

Powyższa funkcja \pyth|texfind_staves_points()| jest odpowiedzialna za znalezienie i stworzenie listy punktów, które definiują pozycję pięciolinii. Funkcja ta przyjmuje za argumenty wczytany obraz, jego nazwę oraz liczbę kroków. Natomiast zwraca listę zawierającą punkty opisujące położenie pięciolinii oraz odległość między liniami pięciolinii, albo wartości zawiadamiające kod wywołujący tę funkcję o wystąpieniu błędu.

Pierwszym krokiem do poprawnej detekcji pięciolinii na obrazie jest uwydatnienie pożądanych jego cech, co jest wykonywane przy pomocy funkcji \pyth|enchance_image()|, dzięki której możliwa jest łatwiejsza analiza badanego obrazu. Następnie następuje wywołanie funkcji odpowiedzialnej za odnalezienie odległości pomiędzy liniami pięciolinii \pyth|find_staff_line_distance()|, poprzez przekazanie obrazu. Jeśli tejże funkcji udało się poprawie odnaleźć szukaną wartość, następuje wywołanie kodu mającego odszukać pozycje pięciolinii na obrazie \pyth|find_staves_positions()| przez przekazanie odnalezionej wcześniej odległości, liczby kroków oraz obrazu. Kiedy operacja się powiedzie, następuje reformatowanie listy uzyskanych punktów przez funkcję \pyth|make_staves_points_list()|, by punkty zawarte w jednej liście zawierały pozycje pojedynczej pięciolinii. Operacja ta jest potrzebna, gdyż uzyskane wartości są ułożone w listach reprezentujących pozycje w pionowych wycinkach, gdzie następna część programu będzie potrzebowała ich w formacie punktów pojedynczej pięciolinii na jedna listę. W wypadku powodzenia wszystkich operacji następuje zwrot listy pozycji oraz odległości pomiędzy liniami pięciolinii.



\subsection{Realizacja uwydatniania obrazu} \label{enhance_image_impl}

\begin{lstlisting} [caption={\pyth|enhance_image()| - funkcja uwydatniania obrazu.}, label={enhance-image}, language=Python]
	def enhance_image(img):
	if len(img.shape) == 3:
		img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
	
	img = cv2.GaussianBlur(img, (5, 5), 0)
	img = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 55, 7)
	
	return img
\end{lstlisting}

Znajdująca się powyżej funkcja ma za zadanie zmodyfikowanie obrazu, by ten nadawał się do jego analizy. Odbywa się to przez konwersję obrazu do odcieni szarości, jeśli jest on obrazem kolorowym, po czym następuje seria modyfikacji, pozwalających na uwydatnienie pożądanych informacji z obrazu.

Pierwszą modyfikacją jest rozmycie gaussowskie, dzięki któremu z obrazu usuwana jest część szumu oraz drobne niedoskonałości są rozmywane, by w następnym kroku możliwe było lepsze określenie wartości znajdujących się ponad progiem. Kolejną modyfikacją zastosowaną na obrazie jest progowanie adaptacyjne, które w przeciwieństwie do zwykłego progowania, pozwala na usunięcie cieni z obrazu, zachowując znajdujące się w nich dane, które mogą być potrzebne do poprawnej analizy. Jednocześnie progowanie adaptacyjne automatycznie znajduje odpowiednie wartości progu, dzięki czemu nie istnieje potrzeba określania go ręcznie, co wymaga znaczącej ilości czasu i prób, by znaleźć taką wartość, która będzie działała w jak najszerszym zakresie danych wejściowych. Ostatnią modyfikacją dotykającą obraz jest erozja, która służy do usunięcia niechcianych punktów i wyostrzenie linii znajdujących się na obrazie, co jest wymagane dla poprawnego odszukiwania pięciolinii.



\subsection{Realizacja odnajdywania odległości między liniami pięciolinii} \label{find_staff_line_distance_impl}

\begin{lstlisting} [caption={ \pyth|find_staff_line_distance()| - funkcja odnajdywania odległości między liniami pięciolinii.}, label={find-staff-line-distance}, language=Python]
def find_staff_line_distance(img = np.array):
	img_y, img_x = img.shape[:2]
	probe_window_size = img_x // 40
	probe_window_start_idx = img_x // 5
	probe_window_end_idx = img_x - probe_window_start_idx
	probe_window_hist_arr = np.zeros(img_y)
	staff_line_distance_list = []
	
	for i in range(probe_window_start_idx, probe_window_end_idx, probe_window_size*6):
		make_histogram_array(i, img_y, probe_window_size, img, probe_window_hist_arr)
		peaks_list = filter_out_peaks(probe_window_size, probe_window_hist_arr)
		staff_line_distance = find_staff_line_distance_in_probe(peaks_list)
		
		if staff_line_distance != 0:
			staff_line_distance_list.append(staff_line_distance)
		
		probe_window_hist_arr = np.zeros(img_y)
	
	if len(staff_line_distance_list) != 0:
		return sum(staff_line_distance_list) // len(staff_line_distance_list)
	else:
		return -1
\end{lstlisting}

Umieszczony powyżej kod funkcji \pyth|find_staff_line_distance()| odpowiedzialny jest za odnalezienie odległości pomiędzy liniami pięciolinii na zdjęciu zapisu nutowego. Funkcja ta zaczyna pracę poprzez inicjalizację niezbędnych zmiennych zawierających wartości takie jak: rozmiary obrazu, rozmiar okienka próbnikowego, indeks początkowy poszukiwania, indeks końcowy, tablicę na której będą przechowywane wartości odczytane z okienka próbnikowego, oraz lista potencjalnych odległości z okienek próbnikowych.

Wartości tych zmiennych nie są przypadkowe, szerokość okienka została dobrana eksperymentalnie, podczas to których eksperymentów stwierdzono, iż wielkość równa jednej czterdziestej szerokości obrazu daje zadowalające rezultaty, dające poprawne wielkości, natomiast pozycja początkowa i końcowa okienka próbnikowego gwarantuje, na poprawnie wykonanych zdjęciach, znajdowanie się pięciolinii w badanym zakresie.

Właściwe odszukiwanie odbywa się iteratywnie poprzez przesuwanie okienka próbnikowego o wielkości większe od jego szerokości, gdyż nie potrzebujemy analizować całego obrazu, tylko kilka jego fragmentów. Analizowanie pojedynczego okienka może dać niepoprawną wartość odległości, zatem obraz jest analizowany w kilku miejscach, by pozyskać właściwą miarę.

W każdym kroku pętli tworzona jest tablica, na podstawie której powstaje histogram okienka, dzięki funkcji \pyth|make_histogram_array()|, która zlicza wystąpienia ciemnych pikseli w  każdym rzędzie badanego okienka. Następnie z uzyskanej tablicy, w funkcji \pyth|filter_out_peaks|, odfiltrowywane są indeksy wysokich wartości histogramu, które powinny być liniami rozpinającymi się na większość szerokości okienka. Na podstawie uzyskanej listy indeksów w funkcji \pyth|find_staff_line_distance()| odszukiwana jest odległość między liniami pięciolinii, dzięki własności zapisu nutowego, w którym najczęściej występującą odległością między dwiema liniami w osi pionowej jest właśnie odległość pomiędzy składowymi pięciolinii. Jeśli odnaleziona wartość nie jest zerem, to jest dodawana do listy potencjalnych odległości. Przed przejściem do następnego kroku pętli, tablica okienka próbnikowego jest zerowana, by poprzednia analiza nie wpływała na analizę kolejnego okienka.

Gdy analiza okienek się zakończy, jeśli lista potencjalnych odległości nie jest pusta, zwracana jest średnia arytmetyczna z listy odległości w formie wartości całkowitej, natomiast jeśli lista jest pusta, zwracana jest wartość \textit{-1}, by poinformować kod wywołujący o błędzie operacji.



\subsection{Realizacja odnajdywania pozycji pięciolinii}

\begin{lstlisting}[caption={\pyth|find_staves_positions()| - funkcja odnajdywania pozycji pięciolinii.}, label={find-staves-positions}, language=Python]
def find_staves_positions(staff_line_distance, stride = 1, img = np.array):
	img_y, img_x = img.shape[:2]
	probe_window_size = (staff_line_distance * 2) + 5
	probe_window_start_idx = probe_window_size * 2
	probe_window_end_idx = img_x - probe_window_start_idx
	probe_window_hist_arr = np.zeros(img_y)
	staves_positions_list = []
	
	for i in range(probe_window_start_idx, probe_window_end_idx, probe_window_size * stride):
		make_histogram_array(i, img_y, probe_window_size, img, probe_window_hist_arr)
		peaks_list = filter_out_peaks(probe_window_size, probe_window_hist_arr)
		staves_positions = get_staves_positions(i, staff_line_distance, peaks_list)
		staves_positions_list.append(staves_positions)
		
		probe_window_hist_arr = np.zeros(img_y)
	
	if len(staves_positions_list) == 0:
		return -1
	else:
		return staves_positions_list
\end{lstlisting}

Odszukiwanie pozycji pięciolinii, realizowane w funkcji \pyth|find_staves_positions()| odbywa się analogicznie do działania \pyth|find_staff_line_distance|, z pewnymi różnicami, mianowicie:
\begin{itemize}
	\item szerokość okienka próbnikowego wynosi dwukrotność odległości między liniami pięciolinii, plus pięć pikseli. Wynika to z właściwości zapisu nutowego, gdzie główka nuty jest nieco szersza, niż odległość między liniami, przez co taka wartość zapewnia, że główka nuty nie będzie zajmowała całej szerokości badanej części obrazu, zaburzając odczytywane dane, scalając ze sobą dwie linie.
	\item początkowa pozycja jest ustalona na dwie szerokości okienka od lewej krawędzi, końcowa zaś na dwie szerokości od prawej krawędzi, by uniknąć niepotrzebnej analizy granic obrazu, na których zazwyczaj nic się nie znajduje, lub znajdują się tam losowe wartości uzyskane z tła.
	\item szerokość kroku jest uzależniona od szerokości okienka oraz przekazanej wartości kroku, która mówi o ile okienko ma się przesuwać w każdym kroku pętli.
	\item po odnalezieniu indeksów dużych wartości histogramu w każdym korku pętli, wywoływana jest funkcja \pyth|get_staves_postitions|, która szuka sekwencji, odległych od siebie o wcześniej odszukaną odległość pięciu indeksów na całej wysokości okienka, tworząc listę punktów z danego wycinka, na którym znajdują się pięciolinie. Zwrócona lista jest dodawana do listy pozycji na których zostały wykryte pięciolinie, po czym resetowana jest tablica okienka próbnikowego.
\end{itemize}


Gdy analiza okienek się zakończy, jeśli lista pozycji nie jest pusta, to jest ona zwracana, natomiast jeśli lista jest pusta, zwraca się wartość \textit{-1}, by poinformować kod wywołujący o błędzie operacji.

\section{Usuwanie wypaczenia obrazu}

Proces usuwania wypaczenia obrazu jest dostosowaną pod potrzeby projektu wersją programu opracowanego przez Matt-a Zucker-a.

Dzięki rozwojowi uczenia maszynowego, by uzyskać dużą skuteczność odczytywania informacji z zapisów nutowych, nie jest wymagane przekształcanie zniekształconego obrazu tak, by pięciolinie posiadały blisko idealnie proste linie, co przy użyciu tradycyjnych metod, jak w wypadku wertykalnego zapadania. Jednakże wytrenowane modele uczenia maszynowego dalej preferują by dane które dostają były jak najbliżej ideału, by były w stanie jak najdokładniej wydobyć dane. Dodatkowo używany w tym projekcie model został wytrenowany na danych zawierających pięciolinie zgrupowane klamrą (akoladą) po dwie, reprezentując zapis dla fortepianu, gdzie radzi sobie również bardzo dobrze z wydobywaniem niezbędnych informacji z pojedynczych pięciolinii, jednak nie jest to cała strona zapisana nutami, więc do jego poprawnego działania niezbędna jest odpowiednia segmentacja danego obrazu, na kawałki zrozumiałe dla modelu, co wymaga, by taki obraz dało się w poprawny sposób pociąć na mniejsze tak, by nie zawierały niepotrzebnych części innych pięciolinii, do czego potrzebne jest właśnie usunięcie wypaczeń obecnych na zdjęciu.

Z racji tego, że nuty często znajdują się w folderach, książkach i innych dokumentach piśmienniczych posiadających usztywniany grzbiet łączący wszystkie jego strony ze sobą, to bez usuwania pojedynczych stron, co często bywa destruktywne, nie da się zrobić takiemu zapisowi zdjęcia, na którym nie byłby on zniekształcony. To, wraz z potrzebą podzielenia obrazu na mniejsze kawałki w odpowiedni sposób powoduje, że krok usuwania wypaczeń jest niezbędny.

Główną ideą implementacji operacji usuwania wypaczania jest model parametryczny, w którym reprezentacja strony jest określana przez szereg parametrów:

\begin{itemize}
	\item wektor rotacji $r$ i translacji $t$, oba w $\mathbb{R}^{3}$, które określają parametry orientacji trójwymiarowej i pozycję strony
	\item dwa parametry nachylenia $\alpha$ i $\beta$, które specyfikują zakrzywienie powierzchni
	\item pionowe offsety $y_{1},\ldots,y_{n}$ dla $n$ poziomych zakresów na stronie
	\item dla każdego zakresu $i \in \{1,\ldots,n\}$, poziome offsety $x_{i}^{(1)},\ldots,x_{i}^{(m_{i})}$ dla $m_{i}$ punktów w horyzontalnej rozpiętości
\end{itemize} 

Trójwymiarowy kształt strony uzyskiwany jest poprzez przeciągnięcie krzywej przy lokalnej osi $y$ w kierunku góra-dół. Każda współrzędna $x$ (lewo-prawo) jest mapowana do przemieszczenia $z$ powierzchni strony. Poziomy przekrój kartki jest zamodelowany jako kwadratowa funkcja sklejana, której końce są zakotwiczone w zerze. Kształt tej funkcji może być całkowicie określony przy pomocy jej parametrów $\alpha$ oraz $\beta$ przy punktach końcowych:

\begin{figure}[h]
	\centering
	\includegraphics[width=8cm]{images/cubic-splines.png}
	\caption{Przykład kwadratowych funkcji sklejanych z różnymi parametrami $\alpha$ oraz $\beta$ z punktami końcowymi zakotwiczonymi w zerze. Źródło: https://mzucker.github.io/2016/08/15/page-dewarping.html}
	\label{fig:cubic-splines}
\end{figure}

Jak powyższy wykres pokazuje, zmiany parametrów $\alpha$ oraz $\beta$ dają nam krzywe, które wyglądają podobnie do przekroju kartki znajdującej się w książce.

W momencie kiedy parametry pozycji i kształtu zostają ustalone, każda współrzędna na stronie zostaje rzutowana by określić jej położenie na płaszczyźnie obrazu. Następnie zaczynając z naiwnego początkowego przypuszczenia, że punkty kluczowe są kolinearne, znajdowane są parametry, $r$, $t$, $\alpha$,  $\beta$, $y_{1},\ldots,y_{n}$, $x_{i}^{(1)},\ldots,x_{i}^{(m_{i})}$ które minimalizują błąd rzutowania punktów kluczowych.

Po uzyskaniu odpowiedniego modelu, parametry pozycji i kształtu zostają wyizolowane i następnie używane do odwrócenia wynikowego mapowania strony na obraz, by usunąć wypaczenie całego obrazu.




\begin{lstlisting}[caption={\pyth|dewarp_page()| - główna funkcja usuwania wypaczania obrazu}, label={dewarp-page}, language=Python]
def dewarp_page(img, img_name, staves_positions_in_list):
	shape = img.shape[:2]
	
	staves_positions = get_norm_pos_list(staves_positions_in_list, shape)
	pagemask, page_outline = get_page_extents(img)
	corners, y_coords, x_coords = keypoints_from_samples(pagemask, page_outline, staves_positions)
	rough_dimensions, span_counts, params = get_default_params(corners, y_coords, x_coords)
	destination_points = np.vstack((corners[0].reshape((1, 1, 2)),) + tuple(staves_positions))
	params = optimize_params(destination_points, span_counts, params)
	page_dimensions = get_page_dimensions(corners, rough_dimensions, params)
	dewarped_image = remap_image(img, page_dimensions, params)
	
	return dewarped_image
\end{lstlisting}

Powyższa funkcja \pyth|dewarp_page()| jest główną funkcją zarządzającą procesem usuwania wypaczenia, przyjmuje ona za argumenty obraz na którym ma zostać wykonana operacja, jego nazwę oraz listę zawierającą listy wykrytych pozycji pięciolinii znajdujących się na obrazie wejściowym.

Rozpoczyna swoje działanie poprzez uzyskanie wymiarów obrazu wejściowego do zmiennej \pyth|shape|, następnie przechodząc do przekształcenia listy wykrytych punktów pięciolinii do postaci norm wektorowych przy pomocy funkcji \pyth|get_norm_pos_list()|.

Kolejnym krokiem jest pozyskanie punktów kluczowych z otrzymanych próbek korzystając z funkcji \pyth|keypoints_form_samples()|. Gdy zostaną one określone, przekazywane są one do funkcji \pyth|get_default_params|, by określić domyślne parametry strony, będące założeniem iż strona jest płaska.

Następnie zostaje stworzona tablica punktów docelowych, poprzez wertykalne połączenie punktu reprezentującego lewy górny róg strony i pozycji wykrytych pięciolinii.

W dalszej kolejności następuje etap optymalizacji otrzymanych parametrów w funkcji \pyth|optimize_params()|, dzięki któremu możliwe jest określenie prawdziwego kształtu strony przeznaczonej do usunięcia jej wypaczenia.

Gdy parametry są już zoptymalizowane, pozyskiwane są wymiary strony znajdującej się na obrazie, dzięki funkcji \pyth|get_page_dimentions()|, które są wymagane do poprawnego remapowania obrazu.

Jak program obliczy wszystkie niezbędne parametry do usunięcia wypaczenia, przechodzi do remapowania obrazu wejściowego w funkcji \pyth|remap_image()|, z której uzyskiwany jest poprawiony obraz, który następnie jest zwracany do kodu wywołującego proces usuwania zniekształcenia strony.

\subsection{Realizacja tworzenia punktów kluczowych z pozyskanych próbek}

\begin{lstlisting}[caption={\pyth|keypoints_from_samples()| - funkcja tworząca tablice punktów kluczowych z pozyskanych próbek.}, label={keypoints-from-samples}, language=Python]
def keypoints_from_samples(pagemask, page_outline, staff_points):
	all_eigen_vectors = np.array([[0.0, 0.0]])
	all_weights = 0
	
	for points in staff_points:
		_, eigen_vector = cv2.PCACompute(points.reshape((-1, 2)), None, maxComponents=1)
		
		weight = np.linalg.norm(points[-1] - points[0])
		
		all_eigen_vectors += eigen_vector * weight
		all_weights += weight
	
	eigen_vector = all_eigen_vectors / all_weights
	x_dir = eigen_vector.flatten()
	
	if x_dir[0] < 0:
		x_dir = -x_dir
	
	y_dir = np.array([-x_dir[1], x_dir[0]])
	
	pagecoords = cv2.convexHull(page_outline)
	pagecoords = utils.pix2norm(pagemask.shape, pagecoords.reshape((-1, 1, 2)))
	pagecoords = pagecoords.reshape((-1, 2))
	
	px_coords = np.dot(pagecoords, x_dir)
	py_coords = np.dot(pagecoords, y_dir)
	
	px0 = px_coords.min()
	px1 = px_coords.max()
	
	py0 = py_coords.min()
	py1 = py_coords.max()
	
	p00 = px0 * x_dir + py0 * y_dir
	p10 = px1 * x_dir + py0 * y_dir
	p11 = px1 * x_dir + py1 * y_dir
	p01 = px0 * x_dir + py1 * y_dir
	
	corners = np.vstack((p00, p10, p11, p01)).reshape((-1, 1, 2))
	
	ycoords = []
	xcoords = []
	
	for points in staff_points:
		pts = points.reshape((-1, 2))
		px_coords = np.dot(pts, x_dir)
		py_coords = np.dot(pts, y_dir)
		ycoords.append(py_coords.mean() - py0)
		xcoords.append(px_coords - px0)
	
	return corners, np.array(ycoords), xcoords
\end{lstlisting}

Funkcja \pyth|keypoints_form_samples()| ma za zadanie wyliczenie pozycji rogów oraz utworzenie tablicy współrzędnych x oraz tablicy współrzędnych y, na podstawie otrzymanej maski strony i jej zarysu oraz listy punktów na których została wykryta pięciolinia.

Na początku działania funkcja inicjuje dwie zmienne: \pyth|all_eigen_vectors|, będącą zmienną mającą przechować wszystkie wektory własne otrzymane z każdej wykrytej pięciolinii, oraz \pyth|all_weight|, która przechowuje wszystkie wagi z list pozycji.

Następnie przechodzi ona po wszystkich listach z listy list punktów pięciolinii znajdujących się na obrazie, gdzie oblicza dla każdej jej wektor własny i jej wagę, które są dodawane do wcześniej utworzonych zmiennych pomocniczych.

Po uzyskaniu wszystkich pożądanych wartości, obliczany jest pojedynczy wektor własny dla całości strony, będący wektorem określającym orientację osi $x$ \pyth|x_dir|, następnie uzyskiwany jest wektor orientacji osi $y$ \pyth|y_dir|.

Kolejnym krokiem jest pozyskanie współrzędnych strony na podstawie jej zarysu, poprzez utworzenie otoczki wklęsłej, używając funkcji \pyth|convexHull()| z biblioteki \textit{cv2}, oraz przetworzenie punktów otoczki na normy wektorowe.

W dalszej kolejności określane są położenia rogów strony poprzez utworzenie tablicy \pyth|corners|, złożonej z wektorów określających ich położenie względem zapisu nutowego.

Ostatnim etapem działania tej funkcji jest stworzenie oddzielnych tablic dla współrzędnych $x$ i $y$, które są następnie wypełniane odpowiednio: \pyth|xcoords| współrzędnymi $x$ wszystkich punktów, przesuniętych względem skrajnego lewego punktu na rozważanej stronie, które są produktem skalarnym względem odchylenia osi $x$, \pyth|ycoords| średnią współrzędnych $y$ każdej wykrytej pięciolinii, która jest przesunięta względem skrajnego górnego punktu rozważanej strony, określone z produktu skalarnego współrzędnych $y$ punktów wykrytych pięciolinii. 

\subsection{Realizacja ustalania początkowych parametrów modelu}
\begin{lstlisting}[caption={\pyth| get_default_params()| - funkcja tworząca początkowe parametry obrazu}, label={get-default-params}, language=Python]
def get_default_params(corners, ycoords, xcoords):
	page_width = np.linalg.norm(corners[1] - corners[0])
	page_height = np.linalg.norm(corners[-1] - corners[0])
	rough_dimensions = (page_width, page_height)
	
	span_counts = [len(xc) for xc in xcoords]
	
	cubic_slopes = [0.0, 0.0]
	
	corners_object3d = np.array([
		[0, 0, 0],
		[page_width, 0, 0],
		[page_width, page_height, 0],
		[0, page_height, 0]])
	
	_, roatation_vector, translation_vector = cv2.solvePnP(corners_object3d, corners, CAMERA_MATRIX, np.zeros(5))
	
	params = np.hstack((np.array(roatation_vector).flatten(), np.array(translation_vector).flatten(), np.array(cubic_slopes).flatten(), ycoords.flatten()) + tuple(xcoords))
	
	return rough_dimensions, span_counts, params
\end{lstlisting}

Powyższa funkcja tworzy wstępne parametry obrazu z wypaczeniem, przyjmując trzy tablice: z rogami strony, współrzędnymi $y$ oraz współrzędnymi $x$. Zwraca przybliżone wymiary strony, tablicę zawierającą informacje o liczebności punktów kluczowych w każdej wykrytej pięciolinii oraz tablicę zawierającą wstępne parametry.

Przybliżone wymiary strony uzyskiwane są poprzez obliczenie norm wektorowych z różnicy wektorów, dla szerokości drugiego i pierwszego elementu tablicy rogów, dla wysokości ostatniego i pierwszego elementu tablicy. 

Tablica liczebności punktów kluczowych w pięcioliniach jest tworzona poprzez przejście pętlą po tablicy \pyth|xcoords| i zliczanie długości wewnętrznych tablic w niej zawartych.

Na parametry składają się wektor rotacji, wektor translacji, tablica parametrów zbocz sklejanej funkcji kwadratowej oraz wektory współrzędnych. 

Wektory translacji i rotacji strony uzyskiwane są z wyniku działania funkcji \pyth|solvePnP| (Perspective-n-Point) biblioteki \textit{cv2}, służącej do obliczania pozycji z kilku zależności dwuwymiarowych w przestrzeni trójwymiarowej. Przekazywane do niej są argumenty wejściowe \pyth|corners_object3d|, który jest założeniem płaskiej strony w przestrzeni trójwymiarowej, \pyth|corners|, zawierający dwuwymiarową, wektorową reprezentację rogów strony, \pyth|CAMERA_MATRIX|, będący macierzą parametrów wewnętrznych kamery, oraz wektor wejściowy współczynników zniekształceń. Gdy wszystkie pożądane wartości zostaną uzyskane, zostają one horyzontalnie złożone do pojedynczej tablicy, używając funkcji \pyth|hstack| z biblioteki \textit{NumPy}.



\subsection{Realizacja tworzenia tablicy indeksującej punkty kluczowe}
\begin{lstlisting}[caption={\pyth|make_keypoint_index()| - funkcja tworząca indeksy punktów kluczowych}, label={make-keypoint-index}, language=Python]
def make_keypoint_index(span_counts):	
	no_of_spans = len(span_counts)
	no_of_points = sum(span_counts)
	keypoint_index = np.zeros((no_of_points+1, 2), dtype=int)
	start = 1
	
	for i, count in enumerate(span_counts):
		end = start + count
		keypoint_index[start:start+end, 1] = 8+i
		start = end
	
	keypoint_index[1:, 0] = np.arange(no_of_points) + 8 + no_of_spans
	
	return keypoint_index
\end{lstlisting}

Zadaniem \pyth|make_keypoint_index()| jest stworzenie listy indeksującej punkty z wykrytych pięciolinii na podstawie liczby ich w konkretnych zakresach zawierających punkty.

Funkcja rozpoczyna działanie inicjując zmienne \pyth|no_of_spans|, przechowującą liczbę wykrytych zakresów zawierających pięciolinie, \pyth|no_of_points|, zawierającą liczbę punktów na których leżą pięciolinie, \pyth|keypoint_index|, dwuwymiarową tablicę rozmiaru $(no_of_points + 1) \times 2$, oraz zmienną pomocniczą \pyth|start|, zainicjowaną wartością \textit{1}.

Następnie w pętli for, zaczynając od drugiego elementu, ustawiane są dla takiej liczby pozycji w liście \pyth|keypoint_index| wartości na drugiej pozycji każdego edytowanego elementu, określające pozycję indeksu współrzędnej $y$ w liście parametrów, odpowiadającą pozycji na płaskiej stronie, ile elementów zawiera dana rozpiętość punktów.

Po przejściu pętli, używając funkcji \pyth|arange()| z biblioteki \textit{NumPy}, ustawiane są na elementach tablicy \pyth|keypoint_index|, od drugiego elementu w górę, na pierwszym miejscu elementów, indeksy współrzędnych $x$ punktów kluczowych.

Uzyskana tablica składa się z par indeksów punktów kluczowych znajdujących się w tablicy parametrów, przy wstępnym założeniu płaskiej strony.


\subsection{project xy}

\begin{lstlisting}[caption={\pyth|project_xy()| - funkcja rzutująca punkty}, label={project-xy}, language=Python]
def project_xy(xy_coords, parameter_vector):	
	alpha, beta = tuple(parameter_vector[CUBIC_IDX])
	poly = np.array([ alpha + beta, -2*alpha - beta, alpha, 0])
	
	xy_coords = xy_coords.reshape((-1, 2))
	z_coords = np.polyval(poly, xy_coords[:, 0])
	
	objpoints = np.hstack((xy_coords, z_coords.reshape((-1, 1))))
	
	image_points, _ = cv2.projectPoints(objpoints, parameter_vector[ROTATION_VECTOR_IDX], parameter_vector[TRANSLATION_VECTOR_IDX], CAMERA_MATRIX, np.zeros(5))
	
	return image_points
\end{lstlisting}

Funkcja \pyth|project_xy()| służy do rzutowania punktów 

Zaczyna ona poprzez uzyskanie parametrów $\alpha$ oraz $\beta$ funkcji sklejanej z wektora parametrów przekazanego jako argument funkcji, następnie z pozyskanych wartości tworzy tablicę \pyth|poly| będącą tablicą parametrów wielomianu.

Kolejno następuje przekształcenie tablicy otrzymanych współrzędnych do pożądanego kształtu. Następnie uzyskiwane są współrzędne $z$ z wykorzystaniem funkcji \pyth|polyval()| należącej do biblioteki \textit{NumPy}, poprzez przekazanie wcześniej utworzonych parametrów wielomianu, oraz współrzędnych $x$ każdego punktu.

W 8 linii tworzona jest zmienna \pyth|objpoints| poprzez horyzontalne złączenie tablicy współrzędnych $x$ i $y$ oraz wcześniej obliczonych współrzędnych $z$, przekształconych do pożądanego rozmiaru.

Gdy wszystkie niezbędne dane zostaną obliczone lub wydobyte, dokonywane jest rzutowanie punktów z obliczonymi współrzędnymi w przestrzeni trójwymiarowej na dwuwymiarowy obraz poprzez wykorzystanie funkcji \pyth|projectPoints()| z biblioteki \textit{cv2}, która otrzymuje tablicę punktów znajdujących się w układzie współrzędnych świata, wektor rotacji, wektor translacji, macierz wewnętrznych parametrów kamery, oraz wektor parametrów dystorsji. 

Z wyniku rzutowania punktów pozyskiwane są punkty obrazu, które następnie zostają zwrócone.


\subsection{Realizacja optymalizacji parametrów modelu}

\begin{lstlisting}[caption={\pyth|optimize_params()| - funkcja optymalizucjąca parametry modelu}, label={optimize-params}, language=Python]
def optimize_params(destination_points, span_counts, params):
	keypoint_index = make_keypoint_index(span_counts)
	
	def objective(parameter_vector):
		parameter_points = project_keypoints(parameter_vector, keypoint_index)
		return np.sum((destination_points - parameter_points)**2)
	
	result = scipy.optimize.minimize(objective, params, method='Powell')
	params = result.x
	return params
\end{lstlisting}

Powyższa funkcja \pyth|optimize_params()| jest najważniejszą funkcją całego procesu usuwania wypaczania obrazu, w której odbywa się zasadnicze zminimalizowanie błędu reprojekcji początkowych estymatów pozycji punktów, dzięki któremu możliwe jest określenie kształtu wypaczonej strony z zapisem nutowym, które jest potrzebne by dało się ten proces poprawnie wykonać.

Początkowym krokiem jest pozyskanie listy indeksującej współrzędne znajdujące się w parametrach przy użyciu funkcji \pyth|make_keypoint_index()|. 

Następnym krokiem jest zadeklarowanie funkcji wewnętrznej \pyth|objective()|, przyjmującej wektor parametrów. Wewnątrz niej następuje stworzenie zmiennej wewnętrznej \pyth|parameter_points| przy użyciu funkcji \pyth|project_keypoints()|, zawierającej listę punktów rzutowanych na obraz. Funkcja ta zwraca kwadrat różnicy punktów docelowych i punktów rzutowanych linię wyżej.

Główną częścią omawianej funkcji jest tworzenie zmiennej \pyth|result| przy pomocy optymalizatora z biblioteki \textit{SciPy}, który dostaje za argumenty wcześniej utworzoną funkcję wewnętrzną, tablicę parametrów oraz wybierana jest metoda optymalizacji przy użyciu algorytmu Powella. Dzięki tej funkcji wstępne założenia położenia są dopasowywane w trójwymiarze do odnalezionych punktów kluczowych na obrazie, pozwalając na odnalezienie kształtu, który ma zostać wyprostowany do płaszczyzny. 

Gdy optymalizacja dobiega końca, ze zmiennej \pyth|result| wyciągane są wartości z pola \pyth|x|, które następnie zostają zwrócone.



\subsection{Realizacja remapowania obrazu}

\begin{lstlisting}[caption={\pyth|remap_image()| - funkcja remapowania wypaczonego obrazu}, label={remap-image}, language=Python]
def remap_image(img, page_dimensions, params):
	height = 0.5 * page_dimensions[1] * img.shape[0]
	height = utils.round_nearest_multiple(height, REMAP_DECIMATE)
	
	width = utils.round_nearest_multiple(height * page_dimensions[0] / page_dimensions[1], REMAP_DECIMATE)
	
	height_small = height // REMAP_DECIMATE
	width_small = width // REMAP_DECIMATE
	
	page_x_range = np.linspace(0, page_dimensions[0], width_small)
	page_y_range = np.linspace(0, page_dimensions[1], height_small)
	
	page_x_coords, page_y_coords = np.meshgrid(page_x_range, page_y_range)
	
	page_xy_coords = np.hstack((page_x_coords.flatten().reshape((-1, 1)), page_y_coords.flatten().reshape((-1, 1))))
	page_xy_coords = page_xy_coords.astype(np.float32)
	
	image_points = project_xy(page_xy_coords, params)
	image_points = utils.norm2pix(img.shape, image_points, False)
	
	image_x_coords = image_points[:, 0, 0].reshape(page_x_coords.shape)
	image_y_coords = image_points[:, 0, 1].reshape(page_y_coords.shape)
	
	image_x_coords = cv2.resize(image_x_coords, (width, height), interpolation=cv2.INTER_CUBIC)
	image_y_coords = cv2.resize(image_y_coords, (width, height), interpolation=cv2.INTER_CUBIC)
	
	img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
	
	remapped = cv2.remap(img_gray, image_x_coords, image_y_coords, cv2.INTER_CUBIC, None, cv2.BORDER_REPLICATE)
	
	thresh = cv2.adaptiveThreshold(remapped, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, ADA_THRESH_WIN_SZ, 25)
	
	return thresh
\end{lstlisting}

Powyższa funkcja \pyth|remap_image()| ma za zadanie, na podstawie wcześniej określonych parametrów, przemapować obraz wejściowy, co jest ostatnim krokiem w usuwaniu wypaczania obrazu, który to jest bezpośrednią manipulacją obrazu, by to wypaczenie usunąć.

Zaczyna ona swoje działanie poprzez zainicjowanie zmiennej \pyth|height|, przechowującą wysokość obrazu wyjściowego, która jest uzyskiwana z połowy wielkości drugiego elementu argumentu \pyth|page_dimensions|, pomnożonego przez wysokość obrazu wejściowego, a następnie zaokrąglonego do najbliżej wielokrotności 16. Szerokość obrazu wyjściowego jest uzyskiwana z najbliżej wielokrotności 16 z szerokości obrazu wyjściowego, pomnożonego przez stosunek szerokości do wysokości strony.

Następnie inicjalizowane zmienne \pyth|height_small| oraz \pyth|width_small|, które są jedną szesnastą odpowiednio: wysokości i szerokości obrazu wyjściowego.

Kolejno tworzone są tablice \pyth|page_x_range| oraz \pyth|page_y_range|, wykorzystując funkcję \pyth|linspace()| biblioteki \textit{NumPy}, równoodległych wartości w zakresie od zera, do odpowiednio: szerokości strony, z liczbą próbek odpowiadającej \pyth|width_small| oraz wysokości strony, z liczbą próbek odpowiadającej \pyth|height_small|. Z pomocą tych tablic tworzone są tablice \pyth|page_x_coords| i \pyth|page_y_coords| korzystając z funkcji \pyth|meshdrid()| biblioteki \textit{NumPy}, która konstruuje siatkę reprezentującą indeksowanie kartezjańskie.

Kolejnym krokiem przygotowującym do remapowania obrazu jest stworzenie tablicy \pyth|page_xy_coords|, składającej się z horyzontalnie połączonych ze sobą i odpowiednio przekształconych tablic \pyth|page_x_coords| i \pyth|page_y_coords|, rzutowanych na typ \textit{float32}.

Dalej tworzona jest tablica \pyth|image_points|, zawierająca rzutowane punkty obrazu przez funkcję \pyth|project_xy| i przekształcona z wartości wektorowych do pozycji pikseli na obrazie wejściowym. Z uzyskanych w ten sposób danych wyciągane są współrzędne $x$ i $y$ do zmiennych \pyth|image_x_coords| oraz \pyth|image_y_coords|, które są przekształcane do pożądanego kształtu, po czym zmieniany jest im rozmiar, by odpowiadały one punktom na obrazie wyjściowym, wykorzystując funkcję \pyth|resize()| biblioteki \textit{cv2} i interpolację dwukwadratową.

Gdy już wszystkie niezbędne parametry są określone, tworzony jest obraz w skali szarości, gdyż informacje o kolorze nie są potrzebne, po czym następuje zasadnicze przekształcenie obrazu, przy pomocy funkcji biblioteki \textit{cv2} \pyth|remap()|, do której zostają przekazane jako argumenty: obraz w skali szarości, mapa współrzędnych $x$, mapa współrzędnych $y$ oraz flaga interpolacji bikwadratowej oraz flaga replikacji wartości granicznych obrazu.

Po zakończonym remapowaniu, otrzymany obraz jest progowany adaptacyjnie, by otrzymać wartości binarne na obrazie, bez cieni i niepotrzebnych do analizy gradientów. Tak zmodyfikowany obraz pozbawiony wypaczenia jest zwracany.


\section{Model głębokiego uczenia do rozpoznawania zapisu nutowego}


















